// Rust test file autogenerated with cargo build (src/build_spectests.rs).
// Please do NOT modify it by hand, as it will be reseted on next build.
// Test based on spectests/float_literals.wast
#![allow(
    warnings,
    dead_code
)]
use crate::webassembly::{instantiate, compile, ImportObject, ResultObject, VmCtx, Export};
use super::_common::spectest_importobject;
use wabt::wat2wasm;


// Line 3
fn create_module_1() -> ResultObject {
    let module_str = "(module
      (type (;0;) (func (result i32)))
      (type (;1;) (func (result i64)))
      (type (;2;) (func (result f32)))
      (type (;3;) (func (result f64)))
      (func (;0;) (type 0) (result i32)
        f32.const nan (;=nan;)
        i32.reinterpret/f32)
      (func (;1;) (type 0) (result i32)
        f32.const nan (;=nan;)
        i32.reinterpret/f32)
      (func (;2;) (type 0) (result i32)
        f32.const -nan (;=nan;)
        i32.reinterpret/f32)
      (func (;3;) (type 0) (result i32)
        f32.const nan (;=nan;)
        i32.reinterpret/f32)
      (func (;4;) (type 0) (result i32)
        f32.const nan:0x200000 (;=nan;)
        i32.reinterpret/f32)
      (func (;5;) (type 0) (result i32)
        f32.const -nan:0x7fffff (;=nan;)
        i32.reinterpret/f32)
      (func (;6;) (type 0) (result i32)
        f32.const nan:0x12345 (;=nan;)
        i32.reinterpret/f32)
      (func (;7;) (type 0) (result i32)
        f32.const nan:0x304050 (;=nan;)
        i32.reinterpret/f32)
      (func (;8;) (type 0) (result i32)
        f32.const -nan:0x2abcde (;=nan;)
        i32.reinterpret/f32)
      (func (;9;) (type 0) (result i32)
        f32.const inf (;=inf;)
        i32.reinterpret/f32)
      (func (;10;) (type 0) (result i32)
        f32.const inf (;=inf;)
        i32.reinterpret/f32)
      (func (;11;) (type 0) (result i32)
        f32.const -inf (;=-inf;)
        i32.reinterpret/f32)
      (func (;12;) (type 0) (result i32)
        f32.const 0x0p+0 (;=0;)
        i32.reinterpret/f32)
      (func (;13;) (type 0) (result i32)
        f32.const 0x0p+0 (;=0;)
        i32.reinterpret/f32)
      (func (;14;) (type 0) (result i32)
        f32.const -0x0p+0 (;=-0;)
        i32.reinterpret/f32)
      (func (;15;) (type 0) (result i32)
        f32.const 0x1.921fb6p+2 (;=6.28319;)
        i32.reinterpret/f32)
      (func (;16;) (type 0) (result i32)
        f32.const 0x1.p-149 (;=1.4013e-45;)
        i32.reinterpret/f32)
      (func (;17;) (type 0) (result i32)
        f32.const 0x1p-126 (;=1.17549e-38;)
        i32.reinterpret/f32)
      (func (;18;) (type 0) (result i32)
        f32.const 0x1.fffffep+127 (;=3.40282e+38;)
        i32.reinterpret/f32)
      (func (;19;) (type 0) (result i32)
        f32.const 0x1.fffffcp-127 (;=1.17549e-38;)
        i32.reinterpret/f32)
      (func (;20;) (type 0) (result i32)
        f32.const 0x1p+10 (;=1024;)
        i32.reinterpret/f32)
      (func (;21;) (type 0) (result i32)
        f32.const 0x0p+0 (;=0;)
        i32.reinterpret/f32)
      (func (;22;) (type 0) (result i32)
        f32.const 0x0p+0 (;=0;)
        i32.reinterpret/f32)
      (func (;23;) (type 0) (result i32)
        f32.const -0x0p+0 (;=-0;)
        i32.reinterpret/f32)
      (func (;24;) (type 0) (result i32)
        f32.const 0x1.921fb6p+2 (;=6.28319;)
        i32.reinterpret/f32)
      (func (;25;) (type 0) (result i32)
        f32.const 0x1.p-149 (;=1.4013e-45;)
        i32.reinterpret/f32)
      (func (;26;) (type 0) (result i32)
        f32.const 0x1p-126 (;=1.17549e-38;)
        i32.reinterpret/f32)
      (func (;27;) (type 0) (result i32)
        f32.const 0x1.fffffcp-127 (;=1.17549e-38;)
        i32.reinterpret/f32)
      (func (;28;) (type 0) (result i32)
        f32.const 0x1.fffffep+127 (;=3.40282e+38;)
        i32.reinterpret/f32)
      (func (;29;) (type 0) (result i32)
        f32.const 0x1.2a05f2p+33 (;=1e+10;)
        i32.reinterpret/f32)
      (func (;30;) (type 0) (result i32)
        f32.const 0x1.000002p+0 (;=1;)
        i32.reinterpret/f32)
      (func (;31;) (type 1) (result i64)
        f64.const nan (;=nan;)
        i64.reinterpret/f64)
      (func (;32;) (type 1) (result i64)
        f64.const nan (;=nan;)
        i64.reinterpret/f64)
      (func (;33;) (type 1) (result i64)
        f64.const -nan (;=nan;)
        i64.reinterpret/f64)
      (func (;34;) (type 1) (result i64)
        f64.const nan (;=nan;)
        i64.reinterpret/f64)
      (func (;35;) (type 1) (result i64)
        f64.const nan:0x4000000000000 (;=nan;)
        i64.reinterpret/f64)
      (func (;36;) (type 1) (result i64)
        f64.const -nan:0xfffffffffffff (;=nan;)
        i64.reinterpret/f64)
      (func (;37;) (type 1) (result i64)
        f64.const nan:0x123456789abc (;=nan;)
        i64.reinterpret/f64)
      (func (;38;) (type 1) (result i64)
        f64.const nan:0x3040506070809 (;=nan;)
        i64.reinterpret/f64)
      (func (;39;) (type 1) (result i64)
        f64.const -nan:0x2abcdef012345 (;=nan;)
        i64.reinterpret/f64)
      (func (;40;) (type 1) (result i64)
        f64.const inf (;=inf;)
        i64.reinterpret/f64)
      (func (;41;) (type 1) (result i64)
        f64.const inf (;=inf;)
        i64.reinterpret/f64)
      (func (;42;) (type 1) (result i64)
        f64.const -inf (;=-inf;)
        i64.reinterpret/f64)
      (func (;43;) (type 1) (result i64)
        f64.const 0x0p+0 (;=0;)
        i64.reinterpret/f64)
      (func (;44;) (type 1) (result i64)
        f64.const 0x0p+0 (;=0;)
        i64.reinterpret/f64)
      (func (;45;) (type 1) (result i64)
        f64.const -0x0p+0 (;=-0;)
        i64.reinterpret/f64)
      (func (;46;) (type 1) (result i64)
        f64.const 0x1.921fb54442d18p+2 (;=6.28319;)
        i64.reinterpret/f64)
      (func (;47;) (type 1) (result i64)
        f64.const 0x1.p-1074 (;=4.94066e-324;)
        i64.reinterpret/f64)
      (func (;48;) (type 1) (result i64)
        f64.const 0x1p-1022 (;=2.22507e-308;)
        i64.reinterpret/f64)
      (func (;49;) (type 1) (result i64)
        f64.const 0x1.ffffffffffffep-1023 (;=2.22507e-308;)
        i64.reinterpret/f64)
      (func (;50;) (type 1) (result i64)
        f64.const 0x1.fffffffffffffp+1023 (;=1.79769e+308;)
        i64.reinterpret/f64)
      (func (;51;) (type 1) (result i64)
        f64.const 0x1p+100 (;=1.26765e+30;)
        i64.reinterpret/f64)
      (func (;52;) (type 1) (result i64)
        f64.const 0x0p+0 (;=0;)
        i64.reinterpret/f64)
      (func (;53;) (type 1) (result i64)
        f64.const 0x0p+0 (;=0;)
        i64.reinterpret/f64)
      (func (;54;) (type 1) (result i64)
        f64.const -0x0p+0 (;=-0;)
        i64.reinterpret/f64)
      (func (;55;) (type 1) (result i64)
        f64.const 0x1.921fb54442d18p+2 (;=6.28319;)
        i64.reinterpret/f64)
      (func (;56;) (type 1) (result i64)
        f64.const 0x1.p-1074 (;=4.94066e-324;)
        i64.reinterpret/f64)
      (func (;57;) (type 1) (result i64)
        f64.const 0x1p-1022 (;=2.22507e-308;)
        i64.reinterpret/f64)
      (func (;58;) (type 1) (result i64)
        f64.const 0x1.ffffffffffffep-1023 (;=2.22507e-308;)
        i64.reinterpret/f64)
      (func (;59;) (type 1) (result i64)
        f64.const 0x1.fffffffffffffp+1023 (;=1.79769e+308;)
        i64.reinterpret/f64)
      (func (;60;) (type 1) (result i64)
        f64.const 0x1.249ad2594c37dp+332 (;=1e+100;)
        i64.reinterpret/f64)
      (func (;61;) (type 1) (result i64)
        f64.const 0x1.000001ff19e24p+0 (;=1;)
        i64.reinterpret/f64)
      (func (;62;) (type 2) (result f32)
        f32.const 0x1.e848p+19 (;=1e+06;))
      (func (;63;) (type 2) (result f32)
        f32.const 0x1.f4p+9 (;=1000;))
      (func (;64;) (type 2) (result f32)
        f32.const 0x1.f5922p+9 (;=1003.14;))
      (func (;65;) (type 2) (result f32)
        f32.const 0x1.c2332cp+49 (;=9.9e+14;))
      (func (;66;) (type 2) (result f32)
        f32.const 0x1.3b5ce8p+93 (;=1.22e+28;))
      (func (;67;) (type 2) (result f32)
        f32.const 0x1.41e014p+27 (;=1.68755e+08;))
      (func (;68;) (type 2) (result f32)
        f32.const 0x1.aa0fp+16 (;=109071;))
      (func (;69;) (type 2) (result f32)
        f32.const 0x1.41ffe2p+15 (;=41215.9;))
      (func (;70;) (type 2) (result f32)
        f32.const 0x1.ep+20 (;=1.96608e+06;))
      (func (;71;) (type 2) (result f32)
        f32.const 0x1.57805p+44 (;=2.36052e+13;))
      (func (;72;) (type 3) (result f64)
        f64.const 0x1.e848p+19 (;=1e+06;))
      (func (;73;) (type 3) (result f64)
        f64.const 0x1.f4p+9 (;=1000;))
      (func (;74;) (type 3) (result f64)
        f64.const 0x1.f5921fafc8bp+9 (;=1003.14;))
      (func (;75;) (type 3) (result f64)
        f64.const 0x1.05c735bb7cc45p-402 (;=9.9e-122;))
      (func (;76;) (type 3) (result f64)
        f64.const 0x1.3b5ce725bde9cp+93 (;=1.22e+28;))
      (func (;77;) (type 3) (result f64)
        f64.const 0x1.5e01e00013332p+51 (;=3.0787e+15;))
      (func (;78;) (type 3) (result f64)
        f64.const 0x1.aa0fp+16 (;=109071;))
      (func (;79;) (type 3) (result f64)
        f64.const 0x1.41ffe2834b34p+15 (;=41215.9;))
      (func (;80;) (type 3) (result f64)
        f64.const 0x1.ep+20 (;=1.96608e+06;))
      (func (;81;) (type 3) (result f64)
        f64.const 0x1.578050f9f7p+44 (;=2.36052e+13;))
      (export \"f32.nan\" (func 0))
      (export \"f32.positive_nan\" (func 1))
      (export \"f32.negative_nan\" (func 2))
      (export \"f32.plain_nan\" (func 3))
      (export \"f32.informally_known_as_plain_snan\" (func 4))
      (export \"f32.all_ones_nan\" (func 5))
      (export \"f32.misc_nan\" (func 6))
      (export \"f32.misc_positive_nan\" (func 7))
      (export \"f32.misc_negative_nan\" (func 8))
      (export \"f32.infinity\" (func 9))
      (export \"f32.positive_infinity\" (func 10))
      (export \"f32.negative_infinity\" (func 11))
      (export \"f32.zero\" (func 12))
      (export \"f32.positive_zero\" (func 13))
      (export \"f32.negative_zero\" (func 14))
      (export \"f32.misc\" (func 15))
      (export \"f32.min_positive\" (func 16))
      (export \"f32.min_normal\" (func 17))
      (export \"f32.max_finite\" (func 18))
      (export \"f32.max_subnormal\" (func 19))
      (export \"f32.trailing_dot\" (func 20))
      (export \"f32_dec.zero\" (func 21))
      (export \"f32_dec.positive_zero\" (func 22))
      (export \"f32_dec.negative_zero\" (func 23))
      (export \"f32_dec.misc\" (func 24))
      (export \"f32_dec.min_positive\" (func 25))
      (export \"f32_dec.min_normal\" (func 26))
      (export \"f32_dec.max_subnormal\" (func 27))
      (export \"f32_dec.max_finite\" (func 28))
      (export \"f32_dec.trailing_dot\" (func 29))
      (export \"f32_dec.root_beer_float\" (func 30))
      (export \"f64.nan\" (func 31))
      (export \"f64.positive_nan\" (func 32))
      (export \"f64.negative_nan\" (func 33))
      (export \"f64.plain_nan\" (func 34))
      (export \"f64.informally_known_as_plain_snan\" (func 35))
      (export \"f64.all_ones_nan\" (func 36))
      (export \"f64.misc_nan\" (func 37))
      (export \"f64.misc_positive_nan\" (func 38))
      (export \"f64.misc_negative_nan\" (func 39))
      (export \"f64.infinity\" (func 40))
      (export \"f64.positive_infinity\" (func 41))
      (export \"f64.negative_infinity\" (func 42))
      (export \"f64.zero\" (func 43))
      (export \"f64.positive_zero\" (func 44))
      (export \"f64.negative_zero\" (func 45))
      (export \"f64.misc\" (func 46))
      (export \"f64.min_positive\" (func 47))
      (export \"f64.min_normal\" (func 48))
      (export \"f64.max_subnormal\" (func 49))
      (export \"f64.max_finite\" (func 50))
      (export \"f64.trailing_dot\" (func 51))
      (export \"f64_dec.zero\" (func 52))
      (export \"f64_dec.positive_zero\" (func 53))
      (export \"f64_dec.negative_zero\" (func 54))
      (export \"f64_dec.misc\" (func 55))
      (export \"f64_dec.min_positive\" (func 56))
      (export \"f64_dec.min_normal\" (func 57))
      (export \"f64_dec.max_subnormal\" (func 58))
      (export \"f64_dec.max_finite\" (func 59))
      (export \"f64_dec.trailing_dot\" (func 60))
      (export \"f64_dec.root_beer_float\" (func 61))
      (export \"f32-dec-sep1\" (func 62))
      (export \"f32-dec-sep2\" (func 63))
      (export \"f32-dec-sep3\" (func 64))
      (export \"f32-dec-sep4\" (func 65))
      (export \"f32-dec-sep5\" (func 66))
      (export \"f32-hex-sep1\" (func 67))
      (export \"f32-hex-sep2\" (func 68))
      (export \"f32-hex-sep3\" (func 69))
      (export \"f32-hex-sep4\" (func 70))
      (export \"f32-hex-sep5\" (func 71))
      (export \"f64-dec-sep1\" (func 72))
      (export \"f64-dec-sep2\" (func 73))
      (export \"f64-dec-sep3\" (func 74))
      (export \"f64-dec-sep4\" (func 75))
      (export \"f64-dec-sep5\" (func 76))
      (export \"f64-hex-sep1\" (func 77))
      (export \"f64-hex-sep2\" (func 78))
      (export \"f64-hex-sep3\" (func 79))
      (export \"f64-hex-sep4\" (func 80))
      (export \"f64-hex-sep5\" (func 81)))
    ";
    let wasm_binary = wat2wasm(module_str.as_bytes()).expect("WAST not valid or malformed");
    instantiate(wasm_binary, spectest_importobject()).expect("WASM can't be instantiated")
}

// Line 105
fn l105_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l105_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2143289344 as i32);
}

// Line 106
fn l106_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l106_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.positive_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2143289344 as i32);
}

// Line 107
fn l107_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l107_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.negative_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -4194304 as i32);
}

// Line 108
fn l108_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l108_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.plain_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2143289344 as i32);
}

// Line 109
fn l109_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l109_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.informally_known_as_plain_snan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2141192192 as i32);
}

// Line 110
fn l110_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l110_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.all_ones_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -1 as i32);
}

// Line 111
fn l111_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l111_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.misc_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2139169605 as i32);
}

// Line 112
fn l112_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l112_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.misc_positive_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2142257232 as i32);
}

// Line 113
fn l113_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l113_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.misc_negative_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -5587746 as i32);
}

// Line 114
fn l114_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l114_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.infinity") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2139095040 as i32);
}

// Line 115
fn l115_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l115_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.positive_infinity") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2139095040 as i32);
}

// Line 116
fn l116_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l116_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.negative_infinity") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -8388608 as i32);
}

// Line 117
fn l117_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l117_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 0 as i32);
}

// Line 118
fn l118_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l118_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.positive_zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 0 as i32);
}

// Line 119
fn l119_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l119_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.negative_zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -2147483648 as i32);
}

// Line 120
fn l120_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l120_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.misc") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1086918619 as i32);
}

// Line 121
fn l121_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l121_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.min_positive") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1 as i32);
}

// Line 122
fn l122_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l122_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.min_normal") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 8388608 as i32);
}

// Line 123
fn l123_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l123_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.max_subnormal") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 8388607 as i32);
}

// Line 124
fn l124_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l124_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.max_finite") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2139095039 as i32);
}

// Line 125
fn l125_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l125_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32.trailing_dot") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1149239296 as i32);
}

// Line 126
fn l126_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l126_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 0 as i32);
}

// Line 127
fn l127_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l127_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.positive_zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 0 as i32);
}

// Line 128
fn l128_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l128_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.negative_zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -2147483648 as i32);
}

// Line 129
fn l129_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l129_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.misc") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1086918619 as i32);
}

// Line 130
fn l130_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l130_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.min_positive") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1 as i32);
}

// Line 131
fn l131_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l131_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.min_normal") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 8388608 as i32);
}

// Line 132
fn l132_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l132_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.max_subnormal") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 8388607 as i32);
}

// Line 133
fn l133_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l133_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.max_finite") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 2139095039 as i32);
}

// Line 134
fn l134_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l134_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.trailing_dot") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1343554297 as i32);
}

// Line 135
fn l135_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l135_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32_dec.root_beer_float") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1065353217 as i32);
}

// Line 137
fn l137_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l137_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9221120237041090560 as i64);
}

// Line 138
fn l138_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l138_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.positive_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9221120237041090560 as i64);
}

// Line 139
fn l139_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l139_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.negative_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -2251799813685248 as i64);
}

// Line 140
fn l140_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l140_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.plain_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9221120237041090560 as i64);
}

// Line 141
fn l141_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l141_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.informally_known_as_plain_snan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9219994337134247936 as i64);
}

// Line 142
fn l142_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l142_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.all_ones_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -1 as i64);
}

// Line 143
fn l143_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l143_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.misc_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9218888453225749180 as i64);
}

// Line 144
fn l144_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l144_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.misc_positive_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9219717281780008969 as i64);
}

// Line 145
fn l145_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l145_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.misc_negative_nan") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -3751748707474619 as i64);
}

// Line 146
fn l146_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l146_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.infinity") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9218868437227405312 as i64);
}

// Line 147
fn l147_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l147_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.positive_infinity") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9218868437227405312 as i64);
}

// Line 148
fn l148_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l148_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.negative_infinity") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -4503599627370496 as i64);
}

// Line 149
fn l149_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l149_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 0 as i64);
}

// Line 150
fn l150_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l150_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.positive_zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 0 as i64);
}

// Line 151
fn l151_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l151_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.negative_zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -9223372036854775808 as i64);
}

// Line 152
fn l152_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l152_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.misc") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 4618760256179416344 as i64);
}

// Line 153
fn l153_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l153_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.min_positive") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1 as i64);
}

// Line 154
fn l154_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l154_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.min_normal") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 4503599627370496 as i64);
}

// Line 155
fn l155_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l155_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.max_subnormal") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 4503599627370495 as i64);
}

// Line 156
fn l156_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l156_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.max_finite") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9218868437227405311 as i64);
}

// Line 157
fn l157_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l157_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64.trailing_dot") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 5057542381537067008 as i64);
}

// Line 158
fn l158_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l158_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 0 as i64);
}

// Line 159
fn l159_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l159_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.positive_zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 0 as i64);
}

// Line 160
fn l160_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l160_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.negative_zero") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, -9223372036854775808 as i64);
}

// Line 161
fn l161_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l161_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.misc") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 4618760256179416344 as i64);
}

// Line 162
fn l162_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l162_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.min_positive") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1 as i64);
}

// Line 163
fn l163_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l163_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.min_normal") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 4503599627370496 as i64);
}

// Line 164
fn l164_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l164_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.max_subnormal") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 4503599627370495 as i64);
}

// Line 165
fn l165_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l165_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.max_finite") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 9218868437227405311 as i64);
}

// Line 166
fn l166_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l166_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.trailing_dot") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 6103021453049119613 as i64);
}

// Line 167
fn l167_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l167_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64_dec.root_beer_float") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> i64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 4607182419335945764 as i64);
}

// Line 169
fn l169_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l169_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-dec-sep1") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1000000.0 as f32);
}

// Line 170
fn l170_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l170_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-dec-sep2") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1000.0 as f32);
}

// Line 171
fn l171_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l171_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-dec-sep3") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1003.1416 as f32);
}

// Line 172
fn l172_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l172_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-dec-sep4") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 990000000000000.0 as f32);
}

// Line 173
fn l173_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l173_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-dec-sep5") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 12200012000000000000000000000.0 as f32);
}

// Line 174
fn l174_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l174_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-hex-sep1") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 168755360.0 as f32);
}

// Line 175
fn l175_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l175_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-hex-sep2") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 109071.0 as f32);
}

// Line 176
fn l176_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l176_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-hex-sep3") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 41215.94 as f32);
}

// Line 177
fn l177_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l177_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-hex-sep4") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1966080.0 as f32);
}

// Line 178
fn l178_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l178_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f32-hex-sep5") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 23605224000000.0 as f32);
}

// Line 180
fn l180_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l180_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-dec-sep1") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1000000.0 as f64);
}

// Line 181
fn l181_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l181_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-dec-sep2") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1000.0 as f64);
}

// Line 182
fn l182_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l182_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-dec-sep3") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1003.141592 as f64);
}

// Line 183
fn l183_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l183_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-dec-sep4") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000099 as f64);
}

// Line 184
fn l184_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l184_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-dec-sep5") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 12200011354000000000000000000.0 as f64);
}

// Line 185
fn l185_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l185_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-hex-sep1") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 3078696982321561.0 as f64);
}

// Line 186
fn l186_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l186_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-hex-sep2") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 109071.0 as f64);
}

// Line 187
fn l187_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l187_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-hex-sep3") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 41215.94240794191 as f64);
}

// Line 188
fn l188_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l188_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-hex-sep4") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 1966080.0 as f64);
}

// Line 189
fn l189_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l189_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("f64-hex-sep5") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 23605225168752.0 as f64);
}

// Line 192

#[test]
fn test_module_1() {
    let result_object = create_module_1();
    let vm_context = result_object.instance.generate_context();
    // We group the calls together
    l105_assert_return_invoke(&result_object, &vm_context);
    l106_assert_return_invoke(&result_object, &vm_context);
    l107_assert_return_invoke(&result_object, &vm_context);
    l108_assert_return_invoke(&result_object, &vm_context);
    l109_assert_return_invoke(&result_object, &vm_context);
    l110_assert_return_invoke(&result_object, &vm_context);
    l111_assert_return_invoke(&result_object, &vm_context);
    l112_assert_return_invoke(&result_object, &vm_context);
    l113_assert_return_invoke(&result_object, &vm_context);
    l114_assert_return_invoke(&result_object, &vm_context);
    l115_assert_return_invoke(&result_object, &vm_context);
    l116_assert_return_invoke(&result_object, &vm_context);
    l117_assert_return_invoke(&result_object, &vm_context);
    l118_assert_return_invoke(&result_object, &vm_context);
    l119_assert_return_invoke(&result_object, &vm_context);
    l120_assert_return_invoke(&result_object, &vm_context);
    l121_assert_return_invoke(&result_object, &vm_context);
    l122_assert_return_invoke(&result_object, &vm_context);
    l123_assert_return_invoke(&result_object, &vm_context);
    l124_assert_return_invoke(&result_object, &vm_context);
    l125_assert_return_invoke(&result_object, &vm_context);
    l126_assert_return_invoke(&result_object, &vm_context);
    l127_assert_return_invoke(&result_object, &vm_context);
    l128_assert_return_invoke(&result_object, &vm_context);
    l129_assert_return_invoke(&result_object, &vm_context);
    l130_assert_return_invoke(&result_object, &vm_context);
    l131_assert_return_invoke(&result_object, &vm_context);
    l132_assert_return_invoke(&result_object, &vm_context);
    l133_assert_return_invoke(&result_object, &vm_context);
    l134_assert_return_invoke(&result_object, &vm_context);
    l135_assert_return_invoke(&result_object, &vm_context);
    l137_assert_return_invoke(&result_object, &vm_context);
    l138_assert_return_invoke(&result_object, &vm_context);
    l139_assert_return_invoke(&result_object, &vm_context);
    l140_assert_return_invoke(&result_object, &vm_context);
    l141_assert_return_invoke(&result_object, &vm_context);
    l142_assert_return_invoke(&result_object, &vm_context);
    l143_assert_return_invoke(&result_object, &vm_context);
    l144_assert_return_invoke(&result_object, &vm_context);
    l145_assert_return_invoke(&result_object, &vm_context);
    l146_assert_return_invoke(&result_object, &vm_context);
    l147_assert_return_invoke(&result_object, &vm_context);
    l148_assert_return_invoke(&result_object, &vm_context);
    l149_assert_return_invoke(&result_object, &vm_context);
    l150_assert_return_invoke(&result_object, &vm_context);
    l151_assert_return_invoke(&result_object, &vm_context);
    l152_assert_return_invoke(&result_object, &vm_context);
    l153_assert_return_invoke(&result_object, &vm_context);
    l154_assert_return_invoke(&result_object, &vm_context);
    l155_assert_return_invoke(&result_object, &vm_context);
    l156_assert_return_invoke(&result_object, &vm_context);
    l157_assert_return_invoke(&result_object, &vm_context);
    l158_assert_return_invoke(&result_object, &vm_context);
    l159_assert_return_invoke(&result_object, &vm_context);
    l160_assert_return_invoke(&result_object, &vm_context);
    l161_assert_return_invoke(&result_object, &vm_context);
    l162_assert_return_invoke(&result_object, &vm_context);
    l163_assert_return_invoke(&result_object, &vm_context);
    l164_assert_return_invoke(&result_object, &vm_context);
    l165_assert_return_invoke(&result_object, &vm_context);
    l166_assert_return_invoke(&result_object, &vm_context);
    l167_assert_return_invoke(&result_object, &vm_context);
    l169_assert_return_invoke(&result_object, &vm_context);
    l170_assert_return_invoke(&result_object, &vm_context);
    l171_assert_return_invoke(&result_object, &vm_context);
    l172_assert_return_invoke(&result_object, &vm_context);
    l173_assert_return_invoke(&result_object, &vm_context);
    l174_assert_return_invoke(&result_object, &vm_context);
    l175_assert_return_invoke(&result_object, &vm_context);
    l176_assert_return_invoke(&result_object, &vm_context);
    l177_assert_return_invoke(&result_object, &vm_context);
    l178_assert_return_invoke(&result_object, &vm_context);
    l180_assert_return_invoke(&result_object, &vm_context);
    l181_assert_return_invoke(&result_object, &vm_context);
    l182_assert_return_invoke(&result_object, &vm_context);
    l183_assert_return_invoke(&result_object, &vm_context);
    l184_assert_return_invoke(&result_object, &vm_context);
    l185_assert_return_invoke(&result_object, &vm_context);
    l186_assert_return_invoke(&result_object, &vm_context);
    l187_assert_return_invoke(&result_object, &vm_context);
    l188_assert_return_invoke(&result_object, &vm_context);
    l189_assert_return_invoke(&result_object, &vm_context);
}
fn create_module_2() -> ResultObject {
    let module_str = "(module
      (type (;0;) (func (result f64)))
      (func (;0;) (type 0) (result f64)
        f64.const 0x1.ffffffa2p+31 (;=4.29497e+09;))
      (export \"4294967249\" (func 0)))
    ";
    let wasm_binary = wat2wasm(module_str.as_bytes()).expect("WAST not valid or malformed");
    instantiate(wasm_binary, spectest_importobject()).expect("WASM can't be instantiated")
}

// Line 201
fn l201_assert_return_invoke(result_object: &ResultObject, vm_context: &VmCtx) {
    println!("Executing function {}", "l201_assert_return_invoke");
    let func_index = match result_object.module.info.exports.get("4294967249") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(&VmCtx) -> f64 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(&vm_context);
    assert_eq!(result, 4294967249.0 as f64);
}

// Line 204
#[test]
fn l204_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 95, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 208
#[test]
fn l208_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 43, 95, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 212
#[test]
fn l212_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 45, 95, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 216
#[test]
fn l216_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 57, 57, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 220
#[test]
fn l220_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 95, 95, 48, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 224
#[test]
fn l224_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 95, 49, 46, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 228
#[test]
fn l228_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 232
#[test]
fn l232_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 95, 46, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 236
#[test]
fn l236_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 46, 95, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 240
#[test]
fn l240_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 95, 49, 101, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 244
#[test]
fn l244_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 101, 49, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 248
#[test]
fn l248_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 95, 101, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 252
#[test]
fn l252_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 101, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 256
#[test]
fn l256_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 95, 49, 46, 48, 101, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 260
#[test]
fn l260_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 101, 49, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 264
#[test]
fn l264_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 95, 101, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 268
#[test]
fn l268_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 101, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 272
#[test]
fn l272_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 101, 43, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 276
#[test]
fn l276_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 101, 95, 43, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 280
#[test]
fn l280_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 95, 48, 120, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 284
#[test]
fn l284_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 95, 120, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 288
#[test]
fn l288_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 95, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 292
#[test]
fn l292_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 48, 48, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 296
#[test]
fn l296_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 102, 102, 95, 95, 102, 102, 102, 102, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 300
#[test]
fn l300_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 95, 49, 46, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 304
#[test]
fn l304_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 308
#[test]
fn l308_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 95, 46, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 312
#[test]
fn l312_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 95, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 316
#[test]
fn l316_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 95, 49, 112, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 320
#[test]
fn l320_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 112, 49, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 324
#[test]
fn l324_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 95, 112, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 328
#[test]
fn l328_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 112, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 332
#[test]
fn l332_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 95, 49, 46, 48, 112, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 336
#[test]
fn l336_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 112, 49, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 340
#[test]
fn l340_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 95, 112, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 344
#[test]
fn l344_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 112, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 348
#[test]
fn l348_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 112, 43, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 352
#[test]
fn l352_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 51, 50, 32, 40, 102, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 112, 95, 43, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 357
#[test]
fn l357_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 95, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 361
#[test]
fn l361_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 43, 95, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 365
#[test]
fn l365_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 45, 95, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 369
#[test]
fn l369_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 57, 57, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 373
#[test]
fn l373_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 95, 95, 48, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 377
#[test]
fn l377_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 95, 49, 46, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 381
#[test]
fn l381_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 385
#[test]
fn l385_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 95, 46, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 389
#[test]
fn l389_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 46, 95, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 393
#[test]
fn l393_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 95, 49, 101, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 397
#[test]
fn l397_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 101, 49, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 401
#[test]
fn l401_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 95, 101, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 405
#[test]
fn l405_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 101, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 409
#[test]
fn l409_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 95, 49, 46, 48, 101, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 413
#[test]
fn l413_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 101, 49, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 417
#[test]
fn l417_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 95, 101, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 421
#[test]
fn l421_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 101, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 425
#[test]
fn l425_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 101, 43, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 429
#[test]
fn l429_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 49, 46, 48, 101, 95, 43, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 433
#[test]
fn l433_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 95, 48, 120, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 437
#[test]
fn l437_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 95, 120, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 441
#[test]
fn l441_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 95, 49, 48, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 445
#[test]
fn l445_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 48, 48, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 449
#[test]
fn l449_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 102, 102, 95, 95, 102, 102, 102, 102, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 453
#[test]
fn l453_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 95, 49, 46, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 457
#[test]
fn l457_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 461
#[test]
fn l461_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 95, 46, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 465
#[test]
fn l465_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 95, 48, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 469
#[test]
fn l469_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 95, 49, 112, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 473
#[test]
fn l473_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 112, 49, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 477
#[test]
fn l477_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 95, 112, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 481
#[test]
fn l481_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 112, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 485
#[test]
fn l485_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 95, 49, 46, 48, 112, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 489
#[test]
fn l489_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 112, 49, 95, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 493
#[test]
fn l493_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 95, 112, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 497
#[test]
fn l497_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 112, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 501
#[test]
fn l501_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 112, 43, 95, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

// Line 505
#[test]
fn l505_assert_malformed() {
    let wasm_binary = [40, 103, 108, 111, 98, 97, 108, 32, 102, 54, 52, 32, 40, 102, 54, 52, 46, 99, 111, 110, 115, 116, 32, 48, 120, 49, 46, 48, 112, 95, 43, 49, 41, 41];
    let compilation = compile(wasm_binary.to_vec());
    assert!(compilation.is_err(), "WASM should not compile as is malformed");
}

#[test]
fn test_module_2() {
    let result_object = create_module_2();
    let vm_context = result_object.instance.generate_context();
    // We group the calls together
    l201_assert_return_invoke(&result_object, &vm_context);
}
