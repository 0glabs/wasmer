//! Create a standalone native executable for a given Wasm file.

use super::ObjectFormat;
use crate::store::CompilerOptions;
use anyhow::{Context, Result};
use clap::Parser;
use serde::{Deserialize, Serialize};
use std::env;
use std::fmt::Write as _;
use std::path::{Path, PathBuf};
use std::process::Command;
use wasmer::*;
use wasmer_object::{emit_serialized, get_object_for_target};
use wasmer_types::compilation::target;
use webc::{ParseOptions, WebCMmap};

/// The `prefixer` returns the a String to prefix each of the
/// functions in the static object generated by the
/// so we can assure no collisions.
#[cfg(feature = "static-artifact-create")]
pub type PrefixerFn = Box<dyn Fn(&[u8]) -> String + Send>;

#[derive(Debug, Parser)]
/// The options for the `wasmer create-exe` subcommand
pub struct CreateExe {
    /// Input file
    #[clap(name = "FILE", parse(from_os_str))]
    path: PathBuf,

    /// Output file
    #[clap(name = "OUTPUT PATH", short = 'o', parse(from_os_str))]
    output: PathBuf,

    /// Optional directorey used for debugging: if present, will output the zig command
    /// for reproducing issues in a debug directory
    #[clap(long, name = "DEBUG PATH", parse(from_os_str))]
    debug_dir: Option<PathBuf>,

    /// Compilation Target triple
    ///
    /// Accepted target triple values must follow the
    /// ['target_lexicon'](https://crates.io/crates/target-lexicon) crate format.
    ///
    /// The recommended targets we try to support are:
    ///
    /// - "x86_64-linux-gnu"
    /// - "aarch64-linux-gnu"
    /// - "x86_64-apple-darwin"
    /// - "arm64-apple-darwin"
    /// - "x86_64-windows-gnu"
    #[clap(long = "target")]
    target_triple: Option<Triple>,

    /// Optional object format (serialized | symbols)
    object_format: Option<ObjectFormat>,

    #[clap(short = 'm')]
    cpu_features: Vec<CpuFeature>,

    /// Additional libraries to link against.
    /// This is useful for fixing linker errors that may occur on some systems.
    #[clap(short = 'l')]
    libraries: Vec<String>,

    #[clap(flatten)]
    cross_compile: CrossCompile,

    #[clap(flatten)]
    compiler: CompilerOptions,
}

// Cross-compilation options with `zig`
#[derive(Debug, Clone, Default, Parser)]
pub(crate) struct CrossCompile {
    /// Cross-compilation library path (path to libwasmer.a / wasmer.lib)
    #[clap(long = "library-path", requires = "target")]
    library_path: Option<PathBuf>,

    /// Cross-compilation tarball library path
    #[clap(long = "tarball", requires = "target")]
    tarball: Option<PathBuf>,

    /// Specify `zig` binary path (defaults to `zig` in $PATH if not present)
    #[clap(long = "zig-binary-path", requires = "target")]
    zig_binary_path: Option<PathBuf>,
}

#[derive(Debug)]
pub(crate) struct CrossCompileSetup {
    pub(crate) target: Triple,
    pub(crate) zig_binary_path: Option<PathBuf>,
    pub(crate) library: Option<PathBuf>,
}

/// Given a pirita file, determines whether the file has one
/// default command as an entrypoint or multiple (need to be specified via --command)
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Entrypoint {
    /// Compiled atom files to link into the final binary
    pub atoms: Vec<CommandEntrypoint>,
    /// Volume objects (if any) to link into the final binary
    pub volumes: Vec<Volume>,
    /// Type of the object format the atoms were compiled with
    pub object_format: ObjectFormat,
}

/// Command entrypoint for multiple commands
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CommandEntrypoint {
    /// Command name
    pub command: String,
    /// Atom name
    pub atom: String,
    /// Path to the object file, relative to the entrypoint.json parent dir
    pub path: PathBuf,
    /// Optional path to the static_defs.h header file, relative to the entrypoint.json parent dir
    pub header: Option<PathBuf>,
}

/// Volume object file (name + path to object file)
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Volume {
    /// Volume name
    pub name: String,
    /// Path to volume fileblock object file
    pub obj_file: PathBuf,
}

impl CreateExe {
    /// Runs logic for the `compile` subcommand
    pub fn execute(&self) -> Result<()> {
        let target_triple = self.target_triple.clone().unwrap_or_else(|| Triple::host());
        let mut cc = CrossCompile {
            library_path: self.cross_compile.library_path.clone(),
            zig_binary_path: self.cross_compile.zig_binary_path.clone(),
            tarball: self.cross_compile.tarball.clone(),
        };
        let target = utils::target_triple_to_target(&target_triple, &self.cpu_features);

        let starting_cd = env::current_dir()?;
        let input_path = starting_cd.join(&self.path);
        let output_path = starting_cd.join(&self.output);
        let cross_compilation =
            utils::get_cross_compile_setup(&mut cc, &target_triple, &starting_cd)?;

        if input_path.is_dir() {
            // assumes that the input directory has been created with create-obj
            link_exe_from_dir(&input_path, output_path, &cross_compilation)?;
        } else if let Ok(pirita) = WebCMmap::parse(input_path.clone(), &ParseOptions::default()) {
            // pirita file
            let temp = tempdir::TempDir::new("pirita-compile")?;
            let tempdir = match self.debug_dir.as_ref() {
                Some(s) => s.clone(),
                None => temp.path().to_path_buf(),
            };
            std::fs::create_dir_all(&tempdir)?;
            compile_pirita_into_directory(
                &pirita,
                &tempdir,
                &self.compiler,
                &self.cpu_features,
                &cross_compilation.target,
                self.object_format.unwrap_or_default(),
            )?;
            link_exe_from_dir(&tempdir, output_path, &cross_compilation)?;
        } else {
            // wasm file
            let temp = tempdir::TempDir::new("pirita-compile")?;
            let tempdir = match self.debug_dir.as_ref() {
                Some(s) => s.clone(),
                None => temp.path().to_path_buf(),
            };
            std::fs::create_dir_all(&tempdir)?;
            prepare_directory_from_single_wasm_file(
                &input_path,
                &tempdir,
                &self.compiler,
                &cross_compilation.target,
                &self.cpu_features,
                self.object_format.unwrap_or_default(),
            )?;
            link_exe_from_dir(&tempdir, output_path, &cross_compilation)?;
        }

        if self.target_triple.is_some() {
            eprintln!(
                "✔ Cross-compiled executable for `{}` target compiled successfully to `{}`.",
                target.triple(),
                self.output.display(),
            );
        } else {
            eprintln!(
                "✔ Native executable compiled successfully to `{}`.",
                self.output.display(),
            );
        }

        Ok(())
    }
}

/// Given a pirita file, compiles the .wasm files into the target directory
pub(super) fn compile_pirita_into_directory(
    pirita: &WebCMmap,
    target_dir: &Path,
    compiler: &CompilerOptions,
    cpu_features: &[CpuFeature],
    triple: &Triple,
    object_format: ObjectFormat,
) -> anyhow::Result<()> {
    let target = &utils::target_triple_to_target(&triple, cpu_features);

    std::fs::create_dir_all(target_dir.join("volumes")).map_err(|e| {
        anyhow::anyhow!(
            "cannot create /volumes dir in {}: {e}",
            target_dir.display()
        )
    })?;

    let volume_bytes = pirita.get_volumes_as_fileblock();
    let volume_name = "VOLUMES";
    let volume_path = target_dir.join("volumes").join("volume.o");
    write_volume_obj(&volume_bytes, &volume_name, &volume_path, &target)?;

    std::fs::create_dir_all(target_dir.join("atoms")).map_err(|e| {
        anyhow::anyhow!("cannot create /atoms dir in {}: {e}", target_dir.display())
    })?;

    let mut atoms_from_file = Vec::new();
    let mut target_paths = Vec::new();

    for (atom_name, atom_bytes) in pirita.get_all_atoms() {
        atoms_from_file.push((atom_name.clone(), atom_bytes.to_vec()));
        let atom_path = target_dir.join("atoms").join(format!("{atom_name}.o"));
        let header_path = match object_format {
            ObjectFormat::Symbols => {
                std::fs::create_dir_all(target_dir.join("include")).map_err(|e| {
                    anyhow::anyhow!(
                        "cannot create /include dir in {}: {e}",
                        target_dir.display()
                    )
                })?;

                Some(
                    target_dir
                        .join("include")
                        .join(format!("static_defs_{atom_name}.h")),
                )
            }
            ObjectFormat::Serialized => None,
        };
        target_paths.push((atom_name, atom_path, header_path));
    }

    conpile_atoms(
        &atoms_from_file,
        &target_dir.join("atoms"),
        &target_dir.join("include"),
        compiler,
        target,
        object_format,
    )?;

    let mut atoms = Vec::new();
    for (atom_name, atom_path, opt_header_path) in target_paths {
        atoms.push(CommandEntrypoint {
            // TODO: improve, "--command pip" should be able to invoke atom "python" with args "-m pip"
            command: atom_name.clone(),
            atom: atom_name.clone(),
            path: atom_path,
            header: opt_header_path,
        });
    }

    let entrypoint = Entrypoint {
        atoms,
        volumes: vec![Volume {
            name: volume_name.to_string(),
            obj_file: volume_path,
        }],
        object_format,
    };

    std::fs::write(
        target_dir.join("entrypoint.json"),
        serde_json::to_string_pretty(&entrypoint).unwrap_or_default(),
    )
    .map_err(|e| {
        anyhow::anyhow!(
            "cannot create entrypoint.json dir in {}: {e}",
            target_dir.display()
        )
    })?;

    Ok(())
}

fn conpile_atoms(
    atoms: &[(String, Vec<u8>)],
    output_dir: &Path,
    header_dir: &Path,
    compiler: &CompilerOptions,
    target: &Target,
    object_format: ObjectFormat,
) -> Result<()> {
    use std::fs::File;
    use std::io::BufWriter;
    use std::io::Write;

    for (atom_name, data) in atoms {
        let (store, _) = compiler.get_store_for_target(target.clone())?;
        let output_object_path = output_dir.join(format!("{atom_name}.o"));

        match object_format {
            ObjectFormat::Symbols => {
                let output_header_path = header_dir.join(format!("static_defs_{atom_name}.h"));

                let engine = store.engine();
                let engine_inner = engine.inner();
                let compiler = engine_inner.compiler()?;
                let features = engine_inner.features();
                let tunables = store.tunables();
                let atom_name_copy = atom_name.clone();
                let prefixer: Option<PrefixerFn> = Some(Box::new(move |_| {
                    utils::normalize_atom_name(&atom_name_copy)
                }));
                let (module_info, obj, metadata_length, symbol_registry) =
                    Artifact::generate_object(
                        compiler, &data, prefixer, &target, tunables, features,
                    )?;

                let header_file_src = crate::c_gen::staticlib_header::generate_header_file(
                    &module_info,
                    &*symbol_registry,
                    metadata_length,
                );
                // Write object file with functions
                let mut writer = BufWriter::new(File::create(&output_object_path)?);
                obj.write_stream(&mut writer)
                    .map_err(|err| anyhow::anyhow!(err.to_string()))?;
                writer.flush()?;

                // Write down header file that includes pointer arrays and the deserialize function
                let mut writer = BufWriter::new(File::create(output_header_path)?);
                writer.write_all(header_file_src.as_bytes())?;
                writer.flush()?;
            }
            ObjectFormat::Serialized => {
                let module =
                    Module::from_binary(&store, &data).context("failed to compile Wasm")?;
                let bytes = module.serialize()?;
                let mut obj = get_object_for_target(target.triple())?;
                emit_serialized(
                    &mut obj,
                    &bytes,
                    target.triple(),
                    &format!(
                        "WASMER_MODULE_{}",
                        utils::normalize_atom_name(atom_name).to_uppercase()
                    ),
                )?;

                let mut writer = BufWriter::new(File::create(&output_object_path)?);
                obj.write_stream(&mut writer)
                    .map_err(|err| anyhow::anyhow!(err.to_string()))?;
                writer.flush()?;
            }
        }
    }

    Ok(())
}

/// Compile the C code.
#[allow(dead_code)]
fn run_c_compile(path_to_c_src: &Path, output_name: &Path, target: &Triple) -> anyhow::Result<()> {
    #[cfg(not(windows))]
    let c_compiler = "cc";
    // We must use a C++ compiler on Windows because wasm.h uses `static_assert`
    // which isn't available in `clang` on Windows.
    #[cfg(windows)]
    let c_compiler = "clang++";

    let mut command = Command::new(c_compiler);
    let command = command
        .arg("-Wall")
        .arg("-O2")
        .arg("-c")
        .arg(path_to_c_src)
        .arg("-I")
        .arg(utils::get_wasmer_include_directory()?)
        .arg("-target")
        .arg(format!("{}", target));

    let output = command.arg("-o").arg(output_name).output()?;
    eprintln!(
        "run_c_compile: stdout: {}\n\nstderr: {}",
        std::str::from_utf8(&output.stdout)
            .expect("stdout is not utf8! need to handle arbitrary bytes"),
        std::str::from_utf8(&output.stderr)
            .expect("stderr is not utf8! need to handle arbitrary bytes")
    );

    if !output.status.success() {
        bail!(
            "C code compile failed with: stdout: {}\n\nstderr: {}",
            std::str::from_utf8(&output.stdout)
                .expect("stdout is not utf8! need to handle arbitrary bytes"),
            std::str::from_utf8(&output.stderr)
                .expect("stderr is not utf8! need to handle arbitrary bytes")
        );
    }

    Ok(())
}

fn write_volume_obj(
    volume_bytes: &[u8],
    object_name: &str,
    output_path: &Path,
    target: &Target,
) -> anyhow::Result<()> {
    use std::fs::File;
    use std::io::BufWriter;
    use std::io::Write;

    let mut volumes_object = get_object_for_target(target.triple())?;
    emit_serialized(
        &mut volumes_object,
        volume_bytes,
        target.triple(),
        object_name,
    )?;

    let mut writer = BufWriter::new(File::create(&output_path)?);
    volumes_object
        .write_stream(&mut writer)
        .map_err(|err| anyhow::anyhow!(err.to_string()))?;
    writer.flush()?;
    drop(writer);

    Ok(())
}

/// Given a .wasm file, compiles the .wasm file into the target directory and creates the entrypoint.json
pub(super) fn prepare_directory_from_single_wasm_file(
    wasm_file: &Path,
    target_dir: &Path,
    compiler: &CompilerOptions,
    triple: &Triple,
    cpu_features: &[CpuFeature],
    object_format: ObjectFormat,
) -> anyhow::Result<()> {
    let bytes = std::fs::read(wasm_file)?;
    let target = &utils::target_triple_to_target(&triple, cpu_features);

    std::fs::create_dir_all(target_dir.join("atoms")).map_err(|e| {
        anyhow::anyhow!("cannot create /atoms dir in {}: {e}", target_dir.display())
    })?;

    let mut atoms_from_file = Vec::new();
    let mut target_paths = Vec::new();

    let all_files = vec![("main".to_string(), bytes)];

    for (atom_name, atom_bytes) in all_files.iter() {
        atoms_from_file.push((atom_name.clone(), atom_bytes.to_vec()));
        let atom_path = target_dir.join("atoms").join(format!("{atom_name}.o"));
        let header_path = match object_format {
            ObjectFormat::Symbols => {
                std::fs::create_dir_all(target_dir.join("include")).map_err(|e| {
                    anyhow::anyhow!(
                        "cannot create /include dir in {}: {e}",
                        target_dir.display()
                    )
                })?;

                Some(
                    target_dir
                        .join("include")
                        .join(format!("static_defs_{atom_name}.h")),
                )
            }
            ObjectFormat::Serialized => None,
        };
        target_paths.push((atom_name, atom_path, header_path));
    }

    conpile_atoms(
        &atoms_from_file,
        &target_dir.join("atoms"),
        &target_dir.join("include"),
        compiler,
        target,
        object_format,
    )?;

    let mut atoms = Vec::new();
    for (atom_name, atom_path, opt_header_path) in target_paths {
        atoms.push(CommandEntrypoint {
            // TODO: improve, "--command pip" should be able to invoke atom "python" with args "-m pip"
            command: atom_name.clone(),
            atom: atom_name.clone(),
            path: atom_path,
            header: opt_header_path,
        });
    }

    let entrypoint = Entrypoint {
        atoms,
        volumes: Vec::new(),
        object_format,
    };

    std::fs::write(
        target_dir.join("entrypoint.json"),
        serde_json::to_string_pretty(&entrypoint).unwrap_or_default(),
    )
    .map_err(|e| {
        anyhow::anyhow!(
            "cannot create entrypoint.json dir in {}: {e}",
            target_dir.display()
        )
    })?;

    Ok(())
}

/// Given a directory, links all the objects from the directory appropriately
fn link_exe_from_dir(
    directory: &Path,
    output_path: PathBuf,
    cross_compilation: &CrossCompileSetup,
) -> anyhow::Result<()> {
    let entrypoint_json =
        std::fs::read_to_string(directory.join("entrypoint.json")).map_err(|e| {
            anyhow::anyhow!(
                "could not read entrypoint.json in {}: {e}",
                directory.display()
            )
        })?;

    let entrypoint: Entrypoint = serde_json::from_str(&entrypoint_json).map_err(|e| {
        anyhow::anyhow!(
            "could not parse entrypoint.json in {}: {e}",
            directory.display()
        )
    })?;

    if entrypoint.atoms.is_empty() {
        return Err(anyhow::anyhow!("file has no atoms to compile"));
    }

    let wasmer_main_c = generate_wasmer_main_c(&entrypoint).map_err(|e| {
        anyhow::anyhow!(
            "could not generate wasmer_main.c in dir {}: {e}",
            directory.display()
        )
    })?;

    std::fs::write(directory.join("wasmer_main.c"), wasmer_main_c.as_bytes()).map_err(|e| {
        anyhow::anyhow!(
            "could not write wasmer_main.c in dir {}: {e}",
            directory.display()
        )
    })?;

    let library_path = cross_compilation
        .library
        .as_ref()
        .ok_or_else(|| anyhow::anyhow!("libwasmer.a / wasmer.lib not found"))?;

    let mut object_paths = entrypoint
        .atoms
        .iter()
        .filter_map(|a| directory.join(&a.path).canonicalize().ok())
        .collect::<Vec<_>>();

    object_paths.extend(
        entrypoint
            .volumes
            .iter()
            .filter_map(|v| directory.join(&v.obj_file).canonicalize().ok()),
    );

    let zig_triple = utils::triple_to_zig_triple(&cross_compilation.target);
    let include_dirs = entrypoint
        .atoms
        .iter()
        .filter_map(|a| {
            Some(
                directory
                    .join(a.header.as_deref()?)
                    .canonicalize()
                    .ok()?
                    .parent()?
                    .to_path_buf(),
            )
        })
        .collect::<Vec<_>>();

    match entrypoint.object_format {
        ObjectFormat::Serialized => {
            if cross_compilation.target == Triple::host() {
                run_c_compile(
                    &directory.join("wasmer_main.c"),
                    &directory.join("wasmer_main.o"),
                    &cross_compilation.target,
                )
                .map_err(|e| {
                    anyhow::anyhow!(
                        "could not write wasmer_main.c in dir {}: {e}",
                        directory.display()
                    )
                })?;

                link_c_compilation()
            } else {
                Err(anyhow::anyhow!(
                    "ObjectFormat::Serialized + cross compilation not implemented"
                ))
            }
        }
        ObjectFormat::Symbols => {
            let zig_binary_path = cross_compilation.zig_binary_path.as_ref().ok_or_else(|| {
                anyhow::anyhow!(
                    "could not write wasmer_main.c in dir {}",
                    directory.display()
                )
            })?;

            let mut cmd = Command::new(&zig_binary_path);
            cmd.arg("build-exe");
            cmd.arg("--verbose-cc");
            cmd.arg("--verbose-link");
            cmd.arg("-target");
            cmd.arg(&zig_triple);

            if zig_triple.contains("windows") {
                cmd.arg("-lc++");
            } else {
                cmd.arg("-lc");
            }

            for include_dir in include_dirs {
                cmd.arg(format!("-I{}", include_dir.display()));
            }

            cmd.arg("-lunwind");
            cmd.arg("-OReleaseSafe");
            cmd.arg("-fno-compiler-rt");
            cmd.arg("-fno-lto");
            #[cfg(target_os = "windows")]
            let out_path = directory.join("wasmer_main.exe");
            #[cfg(not(target_os = "windows"))]
            let out_path = directory.join("wasmer_main");
            cmd.arg(&format!("-femit-bin={}", out_path.display()));
            cmd.args(&object_paths);
            cmd.arg(&library_path);
            cmd.arg(directory.join("wasmer_main.c"));

            if zig_triple.contains("windows") {
                let mut winsdk_path = library_path.clone();
                winsdk_path.pop();
                winsdk_path.pop();
                winsdk_path.push("winsdk");

                let files_winsdk = std::fs::read_dir(winsdk_path)
                    .ok()
                    .map(|res| res.filter_map(|r| Some(r.ok()?.path())).collect::<Vec<_>>())
                    .unwrap_or_default();

                cmd.args(files_winsdk);
            }

            let compilation = cmd.output().context("Could not execute `zig`")?;

            if !compilation.status.success() {
                return Err(anyhow::anyhow!(String::from_utf8_lossy(
                    &compilation.stderr
                )
                .to_string()));
            }

            std::fs::copy(&out_path, &output_path).map_err(|e| {
                anyhow::anyhow!(
                    "could not copy from {} to {}: {e}",
                    out_path.display(),
                    output_path.display()
                )
            })?;

            Ok(())
        }
    }
}

/// Link compiled objects together using the system linker
fn link_c_compilation() -> Result<(), anyhow::Error> {
    // TODO
    Ok(())
}

/// Generate the wasmer_main.c that links all object files together
/// (depending on the object format / atoms number)
fn generate_wasmer_main_c(entrypoint: &Entrypoint) -> Result<String, anyhow::Error> {
    const WASMER_MAIN_C_SOURCE: &str = include_str!("wasmer_create_exe_main.c");

    match entrypoint.object_format {
        ObjectFormat::Serialized => {
            Ok(WASMER_MAIN_C_SOURCE.replace("// WASI_DEFINES", "#define WASI"))
        }
        ObjectFormat::Symbols => {
            let atom_names = entrypoint
                .atoms
                .iter()
                .map(|a| &a.command)
                .collect::<Vec<_>>();

            let mut c_code_to_add = String::new();
            let mut c_code_to_instantiate = String::new();
            let mut deallocate_module = String::new();

            for a in atom_names.iter() {
                let atom_name = utils::normalize_atom_name(&a);
                let atom_name_uppercase = atom_name.to_uppercase();

                c_code_to_add.push_str(&format!(
                    "
                extern size_t {atom_name_uppercase}_LENGTH asm(\"{atom_name_uppercase}_LENGTH\");
                extern char {atom_name_uppercase}_DATA asm(\"{atom_name_uppercase}_DATA\");
                "
                ));

                c_code_to_instantiate.push_str(&format!("
                wasm_byte_vec_t atom_{atom_name}_byte_vec = {{
                    .size = {atom_name_uppercase}_LENGTH,
                    .data = &{atom_name_uppercase}_DATA,
                }};
                wasm_module_t *atom_{atom_name} = wasm_module_deserialize(store, &atom_{atom_name}_byte_vec);
                if (!atom_{atom_name}) {{
                    fprintf(stderr, \"Failed to create module from atom \\\"{atom_name}\\\"\\n\");
                    print_wasmer_error();
                    return -1;
                }}
                "));
                deallocate_module.push_str(&format!("wasm_module_delete(atom_{atom_name});"));
            }

            let return_str = WASMER_MAIN_C_SOURCE
                .replace("#define WASI", "#define WASI\r\n#define WASI_PIRITA")
                .replace("// DECLARE_MODULES", &c_code_to_add)
                .replace("wasm_module_delete(module);", &deallocate_module);

            if atom_names.len() == 1 {
                let atom_to_run = &atom_names[0];
                c_code_to_instantiate.push_str(&format!("module = atom_{atom_to_run};"));
            } else {
                for a in atom_names.iter() {
                    c_code_to_instantiate.push_str(&format!(
                        "if (strcmp(selected_atom, \"{a}\") == 0) {{ module = atom_{}; }}\n",
                        utils::normalize_atom_name(a)
                    ));
                }
            }

            c_code_to_instantiate.push_str(&format!(
                "
            if (!module) {{
                fprintf(stderr, \"No --command given, available commands are:\\n\");
                fprintf(stderr, \"\\n\");
                {commands}
                print_wasmer_error();
                return -1;
            }}
            ",
                commands = atom_names
                    .iter()
                    .map(|a| format!("fprintf(stderr, \"{a}\\n\");"))
                    .collect::<Vec<_>>()
                    .join("\n")
            ));

            Ok(return_str.replace("// INSTANTIATE_MODULES", &c_code_to_instantiate))
        }
    }
}

#[allow(dead_code)]
pub(super) mod utils {

    use super::{CrossCompile, CrossCompileSetup};
    use anyhow::Context;
    use std::env;
    use std::path::{Path, PathBuf};
    use target_lexicon::{Architecture, OperatingSystem, Triple};
    use wasmer_types::{CpuFeature, Target};

    pub(in crate::commands) fn target_triple_to_target(
        target_triple: &Triple,
        cpu_features: &[CpuFeature],
    ) -> Target {
        let mut features = cpu_features
            .clone()
            .into_iter()
            .fold(CpuFeature::set(), |a, b| a | *b);
        // Cranelift requires SSE2, so we have this "hack" for now to facilitate
        // usage
        if target_triple.architecture == Architecture::X86_64 {
            features |= CpuFeature::SSE2;
        }
        Target::new(target_triple.clone(), features)
    }

    pub(in crate::commands) fn get_cross_compile_setup(
        cross_subc: &mut CrossCompile,
        target_triple: &Triple,
        starting_cd: &Path,
    ) -> Result<CrossCompileSetup, anyhow::Error> {
        let target = target_triple;

        if let Some(tarball_path) = cross_subc.tarball.as_mut() {
            if tarball_path.is_relative() {
                *tarball_path = starting_cd.join(&tarball_path);
                if !tarball_path.exists() {
                    return Err(anyhow!(
                        "Tarball path `{}` does not exist.",
                        tarball_path.display()
                    ));
                } else if tarball_path.is_dir() {
                    return Err(anyhow!(
                        "Tarball path `{}` is a directory.",
                        tarball_path.display()
                    ));
                }
            }
        }

        let zig_binary_path = find_zig_binary(cross_subc.zig_binary_path.as_ref().and_then(|p| {
            if p.is_absolute() {
                p.canonicalize().ok()
            } else {
                starting_cd.join(p).canonicalize().ok()
            }
        }))
        .ok();

        let library = if let Some(v) = cross_subc.library_path.clone() {
            Some(v.canonicalize().unwrap_or(v))
        } else {
            if let Some(local_tarball) = cross_subc.tarball.as_ref() {
                find_filename(local_tarball, &target)
            } else {
                // check if the tarball for the target already exists locally
                let local_tarball = std::fs::read_dir(get_libwasmer_cache_path()?)?
                    .filter_map(|e| e.ok())
                    .filter_map(|e| {
                        let path = format!("{}", e.path().display());
                        if path.ends_with(".tar.gz") {
                            Some(e.path())
                        } else {
                            None
                        }
                    })
                    .filter_map(|p| filter_tarballs(&p, &target))
                    .next();

                if let Some(local_tarball) = local_tarball.as_ref() {
                    find_filename(local_tarball, &target)
                } else {
                    let release = super::http_fetch::get_latest_release()?;
                    let tarball = super::http_fetch::download_release(release, target.clone())?;
                    find_filename(&tarball, &target)
                }
            }
            .ok()
            .map(|(filename, tarball_dir)| tarball_dir.join(&filename))
        };
        let ccs = CrossCompileSetup {
            target: target.clone(),
            zig_binary_path,
            library,
        };
        Ok(ccs)
    }

    pub(super) fn find_filename(
        local_tarball: &Path,
        target: &Triple,
    ) -> Result<(String, PathBuf), anyhow::Error> {
        let target_file_path = local_tarball
            .parent()
            .and_then(|parent| Some(parent.join(local_tarball.file_stem()?)))
            .unwrap_or_else(|| local_tarball.to_path_buf());

        let target_file_path = target_file_path
            .parent()
            .and_then(|parent| Some(parent.join(target_file_path.file_stem()?)))
            .unwrap_or_else(|| target_file_path.clone());

        std::fs::create_dir_all(&target_file_path)
            .map_err(|e| anyhow::anyhow!("{e}"))
            .with_context(|| anyhow::anyhow!("{}", target_file_path.display()))?;
        let files =
            super::http_fetch::untar(local_tarball.to_path_buf(), target_file_path.clone())?;
        let tarball_dir = target_file_path.canonicalize().unwrap_or(target_file_path);

        let file = files
        .iter()
        .find(|f| f.ends_with("libwasmer.a")).cloned()
        .ok_or_else(|| {
            anyhow!("Could not find libwasmer.a for {} target in the provided tarball path (files = {files:#?})", target)
        })?;

        Ok((file, tarball_dir))
    }

    pub(super) fn filter_tarballs(p: &Path, target: &Triple) -> Option<PathBuf> {
        if let Architecture::Aarch64(_) = target.architecture {
            if !p.file_name()?.to_str()?.contains("aarch64") {
                return None;
            }
        }

        if let Architecture::X86_64 = target.architecture {
            if !p.file_name()?.to_str()?.contains("x86_64") {
                return None;
            }
        }

        if let OperatingSystem::Windows = target.operating_system {
            if !p.file_name()?.to_str()?.contains("windows") {
                return None;
            }
        }

        if let OperatingSystem::Darwin = target.operating_system {
            if !(p.file_name()?.to_str()?.contains("apple")
                || p.file_name()?.to_str()?.contains("darwin"))
            {
                return None;
            }
        }

        if let OperatingSystem::Linux = target.operating_system {
            if !p.file_name()?.to_str()?.contains("linux") {
                return None;
            }
        }

        Some(p.to_path_buf())
    }

    pub(super) fn normalize_atom_name(s: &str) -> String {
        s.chars()
            .filter_map(|c| {
                if char::is_alphabetic(c) {
                    Some(c)
                } else if c == '-' {
                    Some('_')
                } else {
                    None
                }
            })
            .collect()
    }

    pub(super) fn triple_to_zig_triple(target_triple: &Triple) -> String {
        let arch = match target_triple.architecture {
            wasmer_types::Architecture::X86_64 => "x86_64".into(),
            wasmer_types::Architecture::Aarch64(wasmer_types::Aarch64Architecture::Aarch64) => {
                "aarch64".into()
            }
            v => v.to_string(),
        };
        let os = match target_triple.operating_system {
            wasmer_types::OperatingSystem::Linux => "linux".into(),
            wasmer_types::OperatingSystem::Darwin => "macos".into(),
            wasmer_types::OperatingSystem::Windows => "windows".into(),
            v => v.to_string(),
        };
        let env = match target_triple.environment {
            wasmer_types::Environment::Musl => "musl",
            wasmer_types::Environment::Gnu => "gnu",
            wasmer_types::Environment::Msvc => "msvc",
            _ => "none",
        };
        format!("{}-{}-{}", arch, os, env)
    }

    pub(super) fn get_wasmer_dir() -> anyhow::Result<PathBuf> {
        Ok(PathBuf::from(
            env::var("WASMER_DIR")
                .or_else(|e| {
                    option_env!("WASMER_INSTALL_PREFIX")
                        .map(str::to_string)
                        .ok_or(e)
                })
                .context("Trying to read env var `WASMER_DIR`")?,
        ))
    }

    pub(super) fn get_wasmer_include_directory() -> anyhow::Result<PathBuf> {
        let mut path = get_wasmer_dir()?;
        if path.clone().join("wasmer.h").exists() {
            return Ok(path);
        }
        path.push("include");
        if !path.clone().join("wasmer.h").exists() {
            println!(
                "wasmer.h does not exist in {}, will probably default to the system path",
                path.canonicalize().unwrap().display()
            );
        }
        Ok(path)
    }

    /// path to the static libwasmer
    pub(super) fn get_libwasmer_path() -> anyhow::Result<PathBuf> {
        let path = get_wasmer_dir()?;

        // TODO: prefer headless Wasmer if/when it's a separate library.
        #[cfg(not(windows))]
        let libwasmer_static_name = "libwasmer.a";
        #[cfg(windows)]
        let libwasmer_static_name = "libwasmer.lib";

        if path.exists() && path.join(libwasmer_static_name).exists() {
            Ok(path.join(libwasmer_static_name))
        } else {
            Ok(path.join("lib").join(libwasmer_static_name))
        }
    }

    /// path to library tarball cache dir
    pub(super) fn get_libwasmer_cache_path() -> anyhow::Result<PathBuf> {
        let mut path = get_wasmer_dir()?;
        path.push("cache");
        let _ = std::fs::create_dir(&path);
        Ok(path)
    }

    pub(super) fn get_zig_exe_str() -> &'static str {
        #[cfg(target_os = "windows")]
        {
            "zig.exe"
        }
        #[cfg(not(target_os = "windows"))]
        {
            "zig"
        }
    }

    pub(super) fn find_zig_binary(path: Option<PathBuf>) -> Result<PathBuf, anyhow::Error> {
        use std::env::split_paths;
        use std::ffi::OsStr;
        #[cfg(unix)]
        use std::os::unix::ffi::OsStrExt;
        let path_var = std::env::var("PATH").unwrap_or_default();
        #[cfg(unix)]
        let system_path_var = std::process::Command::new("getconf")
            .args(&["PATH"])
            .output()
            .map(|output| output.stdout)
            .unwrap_or_default();
        let retval = if let Some(p) = path {
            if p.exists() {
                p
            } else {
                return Err(anyhow!("Could not find `zig` binary in {}.", p.display()));
            }
        } else {
            let mut retval = None;
            for mut p in split_paths(&path_var).chain(split_paths(
                #[cfg(unix)]
                {
                    &OsStr::from_bytes(&system_path_var[..])
                },
                #[cfg(not(unix))]
                {
                    OsStr::new("")
                },
            )) {
                p.push(get_zig_exe_str());
                if p.exists() {
                    retval = Some(p);
                    break;
                }
            }
            retval.ok_or_else(|| anyhow!("Could not find `zig` binary in PATH."))?
        };

        let version = std::process::Command::new(&retval)
            .arg("version")
            .output()
            .with_context(|| {
                format!(
                    "Could not execute `zig` binary at path `{}`",
                    retval.display()
                )
            })?
            .stdout;
        let version_slice = if let Some(pos) = version
            .iter()
            .position(|c| !(c.is_ascii_digit() || (*c == b'.')))
        {
            &version[..pos]
        } else {
            &version[..]
        };

        if version_slice < b"0.10.0".as_ref() {
            Err(anyhow!("`zig` binary in PATH (`{}`) is not a new enough version (`{}`): please use version `0.10.0` or newer.", retval.display(), String::from_utf8_lossy(version_slice)))
        } else {
            Ok(retval)
        }
    }

    #[test]
    fn test_normalize_atom_name() {
        assert_eq!(
            normalize_atom_name("atom-name-with-dash"),
            "atom_name_with_dash".to_string()
        );
    }
}

mod http_fetch {
    use anyhow::{anyhow, Context, Result};
    use http_req::{request::Request, response::StatusCode, uri::Uri};
    use std::convert::TryFrom;
    use target_lexicon::OperatingSystem;

    pub(super) fn get_latest_release() -> Result<serde_json::Value> {
        let mut writer = Vec::new();
        let uri = Uri::try_from("https://api.github.com/repos/wasmerio/wasmer/releases").unwrap();

        // Increases rate-limiting in GitHub CI
        let auth = std::env::var("GITHUB_TOKEN");
        let mut response = Request::new(&uri);

        if let Ok(token) = auth {
            response.header("Authorization", &format!("Bearer {token}"));
        }

        let response = response
            .header("User-Agent", "wasmerio")
            .header("Accept", "application/vnd.github.v3+json")
            .timeout(Some(std::time::Duration::new(30, 0)))
            .send(&mut writer)
            .map_err(anyhow::Error::new)
            .context("Could not lookup wasmer repository on Github.")?;

        if response.status_code() != StatusCode::new(200) {
            #[cfg(feature = "debug")]
            log::warn!(
                "Warning: Github API replied with non-200 status code: {}. Response: {}",
                response.status_code(),
                String::from_utf8_lossy(&writer),
            );
        }

        let v: std::result::Result<serde_json::Value, _> = serde_json::from_reader(&*writer);
        let mut response = v.map_err(anyhow::Error::new)?;

        if let Some(releases) = response.as_array_mut() {
            releases.retain(|r| {
                r["tag_name"].is_string() && !r["tag_name"].as_str().unwrap().is_empty()
            });
            releases.sort_by_cached_key(|r| r["tag_name"].as_str().unwrap_or_default().to_string());
            if let Some(latest) = releases.pop() {
                return Ok(latest);
            }
        }

        Err(anyhow!(
            "Could not get expected Github API response.\n\nReason: response format is not recognized:\n{response:#?}",
        ))
    }

    pub(super) fn download_release(
        mut release: serde_json::Value,
        target_triple: wasmer::Triple,
    ) -> Result<std::path::PathBuf> {
        let check_arch = |name: &str| -> bool {
            match target_triple.architecture {
                wasmer_types::Architecture::X86_64 => {
                    name.contains("x86_64") || name.contains("amd64")
                }
                wasmer_types::Architecture::Aarch64(wasmer_types::Aarch64Architecture::Aarch64) => {
                    name.contains("arm64") || name.contains("aarch64")
                }
                _ => false,
            }
        };

        let check_vendor = |name: &str| -> bool {
            match target_triple.vendor {
                wasmer_types::Vendor::Apple => {
                    name.contains("apple") || name.contains("macos") || name.contains("darwin")
                }
                wasmer_types::Vendor::Pc => name.contains("windows"),
                _ => true,
            }
        };
        let check_os = |name: &str| -> bool {
            match target_triple.operating_system {
                wasmer_types::OperatingSystem::Darwin => {
                    name.contains("apple") || name.contains("darwin") || name.contains("macos")
                }
                wasmer_types::OperatingSystem::Windows => name.contains("windows"),
                wasmer_types::OperatingSystem::Linux => name.contains("linux"),
                _ => false,
            }
        };
        let check_env = |name: &str| -> bool {
            match target_triple.environment {
                wasmer_types::Environment::Musl => name.contains("musl"),
                _ => !name.contains("musl"),
            }
        };

        // Test if file has been already downloaded
        if let Ok(mut cache_path) = super::utils::get_libwasmer_cache_path() {
            let paths = std::fs::read_dir(&cache_path).and_then(|r| {
                r.map(|res| res.map(|e| e.path()))
                    .collect::<Result<Vec<_>, std::io::Error>>()
            });

            if let Ok(mut entries) = paths {
                entries.retain(|p| p.to_str().map(|p| p.ends_with(".tar.gz")).unwrap_or(false));

                // create-exe on Windows is special: we use the windows-gnu64.tar.gz (GNU ABI)
                // to link, not the windows-amd64.tar.gz (MSVC ABI)
                if target_triple.operating_system == OperatingSystem::Windows {
                    entries.retain(|p| {
                        p.to_str()
                            .map(|p| p.contains("windows") && p.contains("gnu64"))
                            .unwrap_or(false)
                    });
                } else {
                    entries.retain(|p| p.to_str().map(|p| check_arch(p)).unwrap_or(true));
                    entries.retain(|p| p.to_str().map(|p| check_vendor(p)).unwrap_or(true));
                    entries.retain(|p| p.to_str().map(|p| check_os(p)).unwrap_or(true));
                    entries.retain(|p| p.to_str().map(|p| check_env(p)).unwrap_or(true));
                }

                if !entries.is_empty() {
                    cache_path.push(&entries[0]);
                    if cache_path.exists() {
                        eprintln!(
                            "Using cached tarball to cache path `{}`.",
                            cache_path.display()
                        );
                        return Ok(cache_path);
                    }
                }
            }
        }

        let assets = match release["assets"].as_array_mut() {
            Some(s) => s,
            None => {
                return Err(anyhow!(
                    "GitHub API: no [assets] array in JSON response for latest releases"
                ));
            }
        };

        // create-exe on Windows is special: we use the windows-gnu64.tar.gz (GNU ABI)
        // to link, not the windows-amd64.tar.gz (MSVC ABI)
        if target_triple.operating_system == OperatingSystem::Windows {
            assets.retain(|a| {
                if let Some(name) = a["name"].as_str() {
                    name.contains("windows") && name.contains("gnu64")
                } else {
                    false
                }
            });
        } else {
            assets.retain(|a| {
                if let Some(name) = a["name"].as_str() {
                    check_arch(name)
                } else {
                    false
                }
            });
            assets.retain(|a| {
                if let Some(name) = a["name"].as_str() {
                    check_vendor(name)
                } else {
                    false
                }
            });

            assets.retain(|a| {
                if let Some(name) = a["name"].as_str() {
                    check_os(name)
                } else {
                    false
                }
            });

            assets.retain(|a| {
                if let Some(name) = a["name"].as_str() {
                    check_env(name)
                } else {
                    false
                }
            });
        }

        if assets.len() != 1 {
            return Err(anyhow!(
                "GitHub API: more that one release selected for target {target_triple}: {assets:?}"
            ));
        }

        let browser_download_url = if let Some(url) = assets[0]["browser_download_url"].as_str() {
            url.to_string()
        } else {
            return Err(anyhow!(
                "Could not get download url from Github API response."
            ));
        };

        let filename = browser_download_url
            .split('/')
            .last()
            .unwrap_or("output")
            .to_string();

        let download_tempdir = tempdir::TempDir::new("wasmer-download")?;
        let download_path = download_tempdir.path().join(&filename);

        let mut file = std::fs::File::create(&download_path)?;
        #[cfg(feature = "debug")]
        log::debug!(
            "Downloading {} to {}",
            browser_download_url,
            download_path.display()
        );

        let mut response = reqwest::blocking::Client::builder()
            .redirect(reqwest::redirect::Policy::limited(10))
            .timeout(std::time::Duration::from_secs(10))
            .build()
            .map_err(anyhow::Error::new)
            .context("Could not lookup wasmer artifact on Github.")?
            .get(browser_download_url.as_str())
            .send()
            .map_err(anyhow::Error::new)
            .context("Could not lookup wasmer artifact on Github.")?;

        response
            .copy_to(&mut file)
            .map_err(|e| anyhow::anyhow!("{e}"))?;

        match super::utils::get_libwasmer_cache_path() {
            Ok(mut cache_path) => {
                cache_path.push(&filename);
                if let Err(err) = std::fs::copy(&download_path, &cache_path) {
                    eprintln!(
                        "Could not store tarball to cache path `{}`: {}",
                        cache_path.display(),
                        err
                    );
                    Err(anyhow!(
                        "Could not copy from {} to {}",
                        download_path.display(),
                        cache_path.display()
                    ))
                } else {
                    eprintln!("Cached tarball to cache path `{}`.", cache_path.display());
                    Ok(cache_path)
                }
            }
            Err(err) => {
                eprintln!(
                    "Could not determine cache path for downloaded binaries.: {}",
                    err
                );
                Err(anyhow!("Could not determine libwasmer cache path"))
            }
        }
    }

    pub(super) fn untar(
        tarball: std::path::PathBuf,
        target: std::path::PathBuf,
    ) -> Result<Vec<String>> {
        use walkdir::WalkDir;

        wasmer_registry::try_unpack_targz(&tarball, &target, false)?;

        Ok(WalkDir::new(&target)
            .into_iter()
            .filter_map(|e| e.ok())
            .map(|entry| format!("{}", entry.path().display()))
            .collect())
    }
}
